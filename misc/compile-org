#!/usr/bin/env python3
import argparse
import sys
import tempfile
from subprocess import check_call, check_output
from pathlib import Path

def emacs_version() -> str:
    head = check_output(['emacs', '--version']).decode('utf8').splitlines()[0]
    return head[len("GNU Emacs "):]


# TODO mm, might need to apt install emacs-goodies-el first for code hightlight...
# https://stackoverflow.com/a/24087061/706389

# This is necessary because otherwise emacs loads default outdated org-mode (e.g. in /usr/share) in batch mode
def get_module_path(module: str) -> Path:
    version = emacs_version() # ugh

    pp = Path('~/.emacs.d/elpa/').expanduser()
    matches = list(x for x in pp.glob(f'{version}/*/{module}-*/') if x.is_dir())
    assert len(matches) == 1, matches
    return matches[0]


def filter_private(data: str) -> str:
    lines = [l for l in data.splitlines() if 'NOEXPORT' not in l]
    return '\n'.join(lines)


def main():
    p = argparse.ArgumentParser()
    p.add_argument('--test', type=Path, default=None)
    args = p.parse_args()
    if args.test is not None:
        org_data = args.test.read_text()
    else:
        org_data = sys.stdin.read()
    with tempfile.TemporaryDirectory() as td:
        td = Path(td)

        org_data = filter_private(org_data)

        inp_org  = td / 'input.org'
        inp_org.write_text(org_data)


        out_html = td / 'output.html'

        # TODO make sure it propagates errors properly...
        check_call([
            'emacs',
            '--kill',
            '--batch',
            '--directory', str(get_module_path('org-plus-contrib')),
            '--directory', str(get_module_path('htmlize')),
            str(inp_org),
            '--eval', f'''(progn
; TODO ok, so maybe do not export CREATED property, but show it as a tooltip?
; TODO hmm. find another way to configure these...
; TODO use STRT?
(setq org-todo-keywords '((sequence "TODO" "STRT" "START" "DONE")))

(defun org-export-deterministic-reference (references)
  (let ((new 0))
    (while (rassq new references) (setq new (+ new 1))) ; TODO shit, quadratic time! perhaps start with max??
    new))
(advice-add #'org-export-new-reference :override #'org-export-deterministic-reference)

(setq org-time-stamp-custom-formats
       '("[%Y-%m-%d]" . "[%Y-%m-%d %H:%M]"))

(setq org-display-custom-times 't)

; TODO give tags different colors depending on whether it actually exists or not?
(defun org-blog-tag (path desc fmt)
   (format "<a class='post-tag' href='./tags.html#%s'>#%s</a>" path path)
)
(org-add-link-type "tag" nil 'org-blog-tag)

(defun org-blog-sidenote (path desc fmt)
; TODO ugh. can't nest link inside the sidenote content??
; and writing that on elisp is gonna suck. really need python exporting backend...
; (message (format "HELLOO  =================== %s" desc))
   (format "<aside class='sidenote'>%s</aside>" desc)
)
(org-add-link-type "sidenote" nil 'org-blog-sidenote)
; TODO instead, use some sort of project wise config?

(setq org-export-global-macros '(("aside" . "@@html:<aside>$0</aside>@@")))

(setq org-export-with-author nil)

; https://github.com/gongzhitaao/orgcss#code-highlight
(setq org-html-htmlize-output-type 'css)


(require 'subr-x) ; ugh, for string-join...
(with-eval-after-load 'org
            ; treat mypy highlight as python. see org-html-fontify-code
            (add-to-list 'org-src-lang-modes '("mypy" . python))
            (load-file "~/dotfiles-emacs/babel-mypy.el")

            ; necessary so it doesn't prompt us
            (setq org-confirm-babel-evaluate nil)

            (setq org-babel-python-command "python3"))

; TODO not sure..
; (with-eval-after-load 'python
;             (setq python-indent-guess-indent-offset nil))


; TODO ugh. could be a good idea to write about it. otherwise,
; org-babel-exp-results ignores it on line:
;      (when (fboundp (intern (concat "org-babel-execute:" lang)))
; TODO perhaps good idea at least to sugggest to emit a warning?
(require 'ob-python)


(org-html-export-as-html nil nil nil t)
; t is for BODY-ONLY
(write-file "{str(out_html)}")

            )'''
        ])

        html = out_html.read_text()

        from bs4 import BeautifulSoup
        soup = BeautifulSoup(html, 'lxml')

        # convert all
        # <?>text<aside>something<aside><?>
        # to
        # <div><span>text</span><aside>something</aside></div>
        for aside in soup.find_all('aside'):
            parent = aside.parent

            assert parent.name in {'p', 'li'}
            if parent.name != 'p':
                pp = soup.new_tag(parent.name)
                old = parent.replace_with(pp)
                old.name = 'p'
                pp.append(old)
                parent = old

            assert parent.name == 'p'

            aside.extract()

            div = soup.new_tag('div')
            oldp = parent.replace_with(div)
            div.append(oldp)
            div.append(aside)
            oldp.name = 'span'
            oldp['class'] = oldp.get('class', []) + ['before-aside']
        #


        # convert all
        # <h? id=someid>...</h?>
        # to
        # <h? id=someid><a href='#someid'></a>...</h?>
        # TODO title?
        for lvl in [2, 3]:
            htag = f'h{lvl}'
            for hh in soup.find_all(htag):
                parent = hh.parent

                if parent.name != 'div':
                    continue

                if parent.attrs.get('id') == 'table-of-contents':
                    continue

                pcls = parent.attrs['class']
                if f'outline-{lvl}' not in pcls:
                    continue

                hid = hh.attrs['id']

                newa = soup.new_tag('a', attrs={
                    'href' : '#' + hid,
                    'class': 'headerlink',
                })
                newa.string = 'Â¶'
                hh.insert(0, newa)

        # TODO some whitespace in tags???


        # extract body because that's what hakyll expects
        body = str(soup.find('body'))
        #

        # ugh. didn't find a nice way to extract contents of tag
        assert body.startswith('<body>')
        assert body.endswith('</body>')
        body = body[6: -7]
        sys.stdout.write(body)

if __name__ == '__main__':

    main()
